<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python threading之多线程]]></title>
    <url>%2F2018%2F03%2F19%2Fpython%20threading%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介：python 有两个标准库提供对多线程的支持，thread和threading。其中，thread提供低级别的，原始的线程以及简单的锁。而threading则提供了其他较为高级别，抽象的方法.threading方法： threading.currentThread():返回当前的线程变量。 threading.enumerate():返回一个包含正在运行的线程的列表。 threading.activeCount():返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 此外，threading还提供Thread类来处理线程，Thread类提供了一下方法： run(): 表示线程活动的方法（让线程做什么）。 start(): 启动线程。 join(): 如果一个线程或者一个函数在执行过程中要调用另外一个线程，并且待到其完成以后才能接着执行，那么在调用这个线程时可以使用被调用线程的join方法。 isAlive(): 返回线程是否是活动的。 getName(): 返回线程名。 setName(): 设置线程名。 使用Threading模块创建线程时，直接冲threading.Thread继承，然后重写init和run方法即可： 123456789101112131415161718192021222324252627282930313233343536373839404142import threadingimport timeexitFlags = 0class myThread(threading.Thread): def __init__(self, threadID, name, delay, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay self.counter = counter def run(self): print('开始线程：%s' % self.name) print_time(self.name, self.delay, self.counter) print('结束线程：%s' % self.name) def print_time(threadName, delay, counter): while counter: if exitFlags: threadName.exit() time.sleep(delay) print("%s: %s" % (threadName, time.ctime(time.time()))) counter -= 1threads = []thread1 = myThread(1, 'Thread-1', 2, 5)thread2 = myThread(2, 'Thread-2', 2, 5)threads.append(thread1)threads.append(thread2)for t in threads: t.start()for t in threads: t.join()print('退出主线程！') 线程同步当多个线程同时对同一个变量进行修改时，需要进行线程同步，这就涉及到锁的概念。比如线程1要修改list A，而线程2要打印list A，那么要么是先执行线程1，再执行线程2，或者反之，不能线程1和线程2同时执行，这样就会导致数据不一致性。这就需要每个线程在执行前都需要锁请求，获得锁的线程执行，否则就进入等待状态。使用threading中的Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import threadingimport timeexitFlags = 0class myThread(threading.Thread): #继承父类threading.Thread def __init__(self, threadID, name, delay, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay self.counter = counter # 把要执行的代码写到run函数里面 线程在创建后会直接运行run函数 def run(self): print('开始线程：%s' % self.name) # pass threadLock.acquire() print_time(self.name, self.delay, self.counter) threadLock.release() print('结束线程：%s' % self.name)def print_time(threadName, delay, counter): while counter: if exitFlags: threadName.exit() time.sleep(delay) print("%s: %s" % (threadName, time.ctime(time.time()))) counter -= 1threadLock = threading.Lock()threads = []thread1 = myThread(1, 'Thread-1', 1, 5)thread2 = myThread(2, 'Thread-2', 2, 5)threads.append(thread1)threads.append(thread2)for t in threads: t.start()for t in threads: t.join()print('退出主线程！') 线程的优先级队列python的queue模块提供了同步的，线程安全的队列类，包括FIFO的Queue, LIFO的LifoQueue以及优先级队列PriorityQueue。这些队列都已经在内部实现了锁原语，可以在多线程中直接使用，直接使用队列来实现线程间的同步。 Queue.qsize(): 返回队列的大小。 Queue.empty(): 如果队列为空，则返回True，否则返回False。 Queue.full(): 如果队列满了，则返回True，否则返回False。 Queue.get([block[,timeout]): 获取队列，timeout为等待时间。 Queue.get_nowait()：相当于Queue.get(False)。 Queue.put(item): 写入队列。 Queue.put_nowait(item): 相当于Queue.put(item, False)。 Queue.task_done(): 在完成一项工作之后，向已完成的的队列发送一个信号。 Queue.join(): 等到队列为空，再执行比诶的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import queueimport threadingimport timeexitFlag = 0class myThread(threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name= name self.q = q def run(self): print("开始线程 %s" % self.name) process_data(self.name, self.q) print("结束线程 %s" % self.name)def process_data(threadName, q): while not exitFlag: queueLock.acquire() if not workQueue.empty(): data = q.get() queueLock.release() print('%s: %s' % (threadName, data)) else: queueLock.release() time.sleep(2)threadList = ['Thread-1', 'Thread-2', 'Thread-3']nameList = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nigh', 'ten']queueLock = threading.Lock()workQueue = queue.Queue(10)threads = []threadID = 1# 创建新线程for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1# 填充队列queueLock.acquire()for word in nameList: workQueue.put(word)queueLock.release()# 等待队列清空while not workQueue.empty(): pass# 通知线程退出exitFlag = 1# 等待所有线程完成for t in threads: t.join()print("退出主线程！")]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
